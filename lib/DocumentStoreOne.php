<?php
/** @noinspection TypeUnsafeComparisonInspection
 * @noinspection ClassConstantCanBeUsedInspection
 * @noinspection UnknownInspectionInspection
 * @noinspection MkdirRaceConditionInspection
 * @noinspection PhpUnused
 */

namespace eftec\DocumentStoreOne;

use DateTime;
use Exception;
use Memcache;
use Redis;
use ReflectionObject;
use RuntimeException;

/**
 * Class DocumentStoreOne
 *
 * @version 1.15 2020-09-13
 * @author  Jorge Castro Castillo jcastro@eftec.cl
 * @link    https://github.com/EFTEC/DocumentStoreOne
 * @license LGPLv3
 */
class DocumentStoreOne
{

    const DSO_AUTO = 'auto';
    const DSO_FOLDER = 'folder';
    const DSO_APCU = 'apcu';
    const DSO_MEMCACHE = 'memcached';
    const DSO_REDIS = 'redis';
    /**
     * @var string It is used to append a value without updating the whole file.
     *             This value must be enough complex to avoid collisions.
     *             But it is also must be utf-8 compatible.
     *             10 x 8 bits = 80 bits (1,208,925,819,614,629,174,706,176 chances of colision)
     */
    public $separatorAppend = "~§¶¤¶¤¶§~\n";
    /** @var string root folder of the database */
    public $database;
    /** @var string collection (subfolder) of the database */
    public $collection;
    /** @var int Maximium duration of the lock (in seconds). By default it's 2 minutes */
    public $maxLockTime = 120;
    /** @var int Default number of retries. By default it tries 100x0.1sec=10 seconds */
    public $defaultNumRetry = 100;
    /** @var int Interval (in microseconds) between retries. 100000 means 0.1 seconds */
    public $intervalBetweenRetry = 100000;
    /** @var string Default extension (with dot) of the document */
    public $docExt = ".dson";
    /** @var string=['php','php_array','json_object','json_array','none'][$i] */
    public $serializeStrategy = 'php';
    /** @var bool if true then it will never lock or unlock the document. It is useful for a read only base */
    public $neverLock = false;
    /** @var int DocumentStoreOne::DSO_* */
    public $strategy = self::DSO_FOLDER;
    /** @var Redis */
    public $redis;
    /** @var string=['','md5','sha1','sha256','sha512'][$i] Indicates if the key is encrypted or not when it's stored (the file name). Empty means, no encryption. You could use md5,sha1,sha256,.. */
    public $keyEncryption = '';
    /**
     * @var int nodeId It is the identifier of the node.<br>
     * It must be between 0..1023<br>
     * If the value is -1, then it randomizes it's value each call.
     */
    public $nodeId = 1;
    private $autoSerialize;
    /** @var Memcache */
    private $memcache;
    /**
     * @var string= 'sequencephp' (snowfake generation),'nextsequence' (generated by a document) or the name of the field.
     */
    private $objectIndex;

    /**
     * DocumentStoreOne constructor.<br>
     * <b>Example</b>:
     * <pre>
     * $obj=new DocumentStoreOne(__DIR__."/base",'collectionFolder');
     * </pre>
     *
     * @param string $database      root folder of the database
     * @param string $collection    collection (subfolder) of the database. If the collection is empty then it uses the root folder.
     * @param string $strategy      =['auto','folder','apcu','memcached','redis'][$i] The strategy is only used to lock/unlock purposes.
     * @param string $server        Used for 'memcached' (localhost:11211) and 'redis' (localhost:6379)
     * @param bool   $autoSerialize If true then the value (inserted) is auto serialized
     * @param string $keyEncryption =['','md5','sha1','sha256','sha512'][$i] it uses to encrypt the name of the keys (filename)
     *
     * @throws RuntimeException
     * @example $flatcon=new DocumentStoreOne(__DIR__."/base",'collectionFolder');
     */
    public function __construct(
        $database,
        $collection = '',
        $strategy = 'auto',
        $server = "",
        $autoSerialize = false,
        $keyEncryption = ''
    ) {
        $this->database = $database;
        $this->collection = $collection;
        $this->autoSerialize = $autoSerialize;
        $this->keyEncryption = $keyEncryption;

        //$r=$memcache->connect(MEMCACHE_SERVER, MEMCACHE_PORT);
        $this->setStrategy($strategy, $server);

        if (!is_dir($this->getPath())) {
            throw new RuntimeException("Tsk Tsk, the folder is incorrect or I'm not unable to read  it: "
                . $this->getPath() .
                '. You could create the collection with createCollection()');
        }
    }

    /**
     * It sets the strategy to lock and unlock the folders
     *
     * @param string|int $strategy =['auto','folder','apcu','memcached','redis'][$i]
     * @param string     $server
     *
     * @throws RuntimeException
     */
    public function setStrategy($strategy, $server = "")
    {
        if ($strategy === self::DSO_AUTO) {
            if (function_exists('apcu_add')) {
                $this->strategy = self::DSO_APCU;
            } elseif (class_exists('\Memcache')) {
                $this->strategy = self::DSO_MEMCACHE;
            } else {
                $this->strategy = self::DSO_FOLDER;
            }
            $strategy = $this->strategy;
        } else {
            $this->strategy = $strategy;
        }
        switch ($strategy) {
            case self::DSO_FOLDER:
                break;
            case self::DSO_APCU:
                if (!function_exists("apcu_add")) {
                    throw new RuntimeException("APCU is not defined");
                }
                break;
            case self::DSO_MEMCACHE:
                if (!class_exists("\Memcache")) {
                    throw new RuntimeException("Memcache is not defined");
                }
                $this->memcache = new Memcache();
                $host = explode(':', $server);
                $r = @$this->memcache->pconnect($host[0], $host[1]);
                if (!$r) {
                    throw new RuntimeException("Memcache is not open");
                }
                break;
            case self::DSO_REDIS:
                if (!class_exists("\Redis")) {
                    throw new RuntimeException("Redis is not defined");
                }
                if (function_exists('cache')) {
                    $this->redis = cache();// inject using the cache function (if any).
                } else {
                    $this->redis = new Redis();
                    $host = explode(':', $server);
                    $r = @$this->redis->pconnect($host[0], $host[1], 30); // 30 seconds timeout
                    if (!$r) {
                        throw new RuntimeException("Redis is not open");
                    }
                }
                break;
            default:
                throw new RuntimeException("Strategy not defined");
        }
    }

    /**
     * It gets the current path.
     *
     * @return string
     */
    private function getPath()
    {
        return $this->database . "/" . $this->collection;
    }

    /**
     * Util function to fix the cast of an object.
     * Usage utilCache::fixCast($objectRightButEmpty,$objectBadCast);
     *
     * @param object|array $destination Object may be empty with the right cast.
     * @param object|array $source      Object with the wrong cast.
     *
     * @return void
     */
    public static function fixCast(&$destination, $source)
    {
        if (is_array($source)) {
            $getClass = get_class($destination[0]);
            $array = array();
            foreach ($source as $sourceItem) {
                $obj = new $getClass();
                self::fixCast($obj, $sourceItem);
                $array[] = $obj;
            }
            $destination = $array;
        } else {
            $sourceReflection = new ReflectionObject($source);
            $sourceProperties = $sourceReflection->getProperties();
            foreach ($sourceProperties as $sourceProperty) {
                $name = $sourceProperty->getName();
                if (is_object(@$destination->{$name})) {
                    if (get_class(@$destination->{$name}) === "DateTime") {
                        // source->name is a stdclass, not a DateTime, so we could read the value with the field date
                        try {
                            $destination->{$name} = new DateTime($source->$name->date);
                        } catch (Exception $e) {
                            $destination->{$name} = null;
                        }
                    } else {
                        self::fixCast($destination->{$name}, $source->$name);
                    }
                } else {
                    $destination->{$name} = $source->$name;
                }
            }
        }
    }

    /**
     * Set if we need to lock/unlock every time we want to read/write a value
     *
     * @param bool $neverLock if its true the the register is never locked. It is fast but it's not concurrency-safe
     */
    public function setNeverLock($neverLock = true)
    {
        $this->neverLock = $neverLock;
    }

    /**
     * It appends a value to an existing document. It creates an array of values if it doesn't exists.<br>
     * <b>Example:</b>
     * <pre>
     * $this->appendvalue('20',[1,2,3]); // document "20" = [[1,2,3]]
     * $this->appendvalue('20',[3,4,5]); // document "20" = [[1,2,3],[3,4,5]]
     * </pre>
     * 
     *
     * @param string $id       id of the document.
     * @param mixed  $addValue This value could be serialized.
     * @param int    $tries    number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool It returns false if it fails to lock the document or if it's unable to read the document. Otherwise it returns true
     * @throws RuntimeException
     */
    public function appendValue($id, $addValue, $tries = -1)
    {

        /*if ($this->serializeStrategy === 'php_array') {
            throw new RuntimeException('appendValue doesnt work with php_array');
        }*/
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            switch ($this->serializeStrategy) {
                case 'json_array':
                case 'json_object':
                case 'php_array':
                    if($this->ifExist($id,null)) {
                        $fp = @fopen($file, 'rb+');
                    } else {
                        $this->unlock($file);
                        return $this->insert($id,[$addValue],$tries);
                    }
                    if ($fp === false) {
                        $this->unlock($file);
                        return false; // file exists but i am unable to open it.
                    }
                    if ($this->serializeStrategy==='php_array') {
                        fseek($fp, -4, SEEK_END);
                        $addValue = $this->serialize($addValue,true);
                        $r = @fwrite($fp,','.$addValue.");\n "); //note: ");\n " it must be exactly 4 characters.
                    } else {
                        fseek($fp, -1, SEEK_END);
                        $addValue = $this->serialize($addValue,true);
                        $r = @fwrite($fp,','.$addValue.']');    
                    }
                    
                    @fclose($fp);
                    $this->unlock($file);
                    return ($r !== false);
                
                   
                default:
                    $fp = @fopen($file, 'ab');
                    if ($fp === false) {
                        $this->unlock($file);
                        return false; // file exists but i am unable to open it.
                    }
                    $addValue = $this->serialize($addValue);
                    $addValue = $this->separatorAppend . $addValue;
                    $r = @fwrite($fp, $addValue);
                    @fclose($fp);
                    $this->unlock($file);
                    return ($r !== false);
            }

        }
        return false; // unable to lock
    }

    /**
     * Convert Id to a full filename. If keyencryption then the name is encrypted.
     *
     * @param string $id
     *
     * @return string full filename
     */
    private function filename($id)
    {
        $file = $this->keyEncryption ? hash($this->keyEncryption, $id) : $id;
        return $this->getPath() . "/" . $file . $this->docExt;
    }

    /**
     * It locks a file
     *
     * @param     $filepath
     * @param int $maxRetry
     *
     * @return bool
     */
    private function lock($filepath, $maxRetry = -1)
    {
        if ($this->neverLock) {
            return true;
        }
        $maxRetry = ($maxRetry === -1) ? $this->defaultNumRetry : $maxRetry;
        if ($this->strategy === self::DSO_APCU) {
            $try = 0;
            while (@apcu_add("documentstoreone." . $filepath, 1, $this->maxLockTime) === false && $try < $maxRetry) {
                $try++;
                usleep($this->intervalBetweenRetry);
            }
            return ($try < $maxRetry);
        }
        if ($this->strategy === self::DSO_MEMCACHE) {
            $try = 0;
            while (@$this->memcache->add("documentstoreone." . $filepath, 1, 0, $this->maxLockTime) === false
                && $try < $maxRetry) {
                $try++;
                usleep($this->intervalBetweenRetry);
            }
            return ($try < $maxRetry);
        }
        if ($this->strategy === self::DSO_REDIS) {
            $try = 0;
            while (@$this->redis->set("documentstoreone." . $filepath, 1, ['NX', 'EX' => $this->maxLockTime]) !==
                true
                && $try < $maxRetry) {
                $try++;
                usleep($this->intervalBetweenRetry);
            }
            return ($try < $maxRetry);
        }
        if ($this->strategy === self::DSO_FOLDER) {
            clearstatcache();

            $lockname = $filepath . ".lock";
            $life = @filectime($lockname);
            $try = 0;
            while (!@mkdir($lockname) && $try < $maxRetry) {
                $try++;
                if ($life && (time() - $life) > $this->maxLockTime) {
                    rmdir($lockname);
                    $life = false;
                }
                usleep($this->intervalBetweenRetry);
            }
            return ($try < $maxRetry);
        }
        return false;
    }

    /**
     * Unlocks a document
     *
     * @param string $filepath full file path/key of the document to unlock.
     *
     * @return bool
     */
    private function unlock($filepath)
    {
        if ($this->neverLock) {
            return true;
        }
        switch ($this->strategy) {
            case self::DSO_APCU:
                return apcu_delete("documentstoreone." . $filepath);
            case self::DSO_MEMCACHE:
                return $this->memcache->delete("documentstoreone." . $filepath);
            case self::DSO_REDIS:
                return ($this->redis->del("documentstoreone." . $filepath) > 0);
        }
        $unlockname = $filepath . ".lock";
        $try = 0;
        // retry to delete the unlockname folder. If fails then it tries it again.
        while (!@rmdir($unlockname) && $try < $this->defaultNumRetry) {
            $try++;
            usleep($this->intervalBetweenRetry);
        }
        return ($try < $this->defaultNumRetry);
    }

    /**
     * @param $document
     *
     * @return string
     */
    private function serialize($document,$special=false)
    {
        switch ($this->serializeStrategy) {
            case 'php_array':
                return self::serialize_php_array($document,$special);
            case 'php':
                return serialize($document);
            case 'json_object':
            case 'json_array':
                return json_encode($document);
            default:
                // also for none
                return $document;
        }
    }

    private static function serialize_php_array($document,$special=false)
    {
        if($special) {
            // for append
            return var_export($document, true);
        } else {
            return "<?php /** @generated */\nreturn " . var_export($document, true) . ';';    
        }
        
    }

    /**
     * It sets the default object field used for index.
     *
     * @param string $indexField
     */
    public function setObjectIndex($indexField)
    {
        $this->objectIndex = $indexField;
    }

    /**
     * It inserts (or update) an associative array or an object into the document store<br>
     * Example:<br>
     * $obj=['id'=>1,'name'=>'john'];<br>
     * $doc->insertOrUpdateObject($obj,'id');<br>
     *
     * @param array|object $object     The object (or associative array) to store
     * @param null|string  $indexField =['sequencephp','nextsequence'][$i]<br>
     *                                 if null then it uses the default index field defined by setObjectIndex()<br>
     *                                 if sequencephp then it uses snowflake for generate a new sequence<br>
     *                                 if nextsequence then it uses a document sequence<br>
     *
     * @return string the index value
     * @see \eftec\DocumentStoreOne\DocumentStoreOne::setObjectIndex
     */
    public function insertOrUpdateObject($object, $indexField = null)
    {
        return $this->insertObject($object, $indexField, 'insertorupdate');
    }

    /**
     * It inserts an associative array or an object into the document store
     *
     * @param array|object $object     The object to store
     * @param null|string  $indexField =['sequencephp','nextsequence'][$i]<br>
     *                                 if null then it uses the default index field defined by setObjectIndex()<br>
     *                                 if sequencephp then it uses snowflake for generate a new sequence<br>
     *                                 if nextsequence then it uses a document sequence<br>
     *
     * @param string       $operation  =['insert','insertorupdate'][$i]
     *
     * @return string the index value
     * @see \eftec\DocumentStoreOne\DocumentStoreOne::setObjectIndex
     */
    public function insertObject($object, $indexField = null, $operation = 'insert')
    {
        if ($indexField === null) {
            $indexField = $this->objectIndex;
        }
        switch ($indexField) {
            case 'sequencephp':
                $idx = $this->getSequencePHP();
                break;
            case 'nextsequence':
                $idx = $this->getNextSequence();
                break;
            default:
                $idx = $indexField;
                $idx = is_object($object) ? $object->{$idx} : $object[$idx];
        }
        try {
            switch ($operation) {
                case 'insert':
                    $this->insert($idx, $object);
                    break;
                case 'insertorupdate':
                    $this->insertOrUpdate($idx, $object);
                    break;
                default:
                    trigger_error('insertObject: operation not defined');
            }
            return $idx;
        } catch (Exception $ex) {
            return false;
        }
    }

    /**
     * <p>This function returns an unique sequence<p>
     * It ensures a collision free number only if we don't do more than one operation
     * per 0.0001 second However,it also adds a pseudo random number (0-4095)
     * so the chances of collision is 1/4095 (per two operations executed every 0.0001 second).<br>
     * It is based on Twitter's Snowflake number.
     *
     * @return float (it returns a 64bit integer).
     */
    public function getSequencePHP()
    {
        $ms = microtime(true); // we use this number as a random number generator (we use the decimals)
        //$ms=1000;
        $timestamp = (double)round($ms * 1000);
        $rand = (fmod($ms, 1) * 1000000) % 4096; // 4096= 2^12 It is the millionth of seconds
        if ($this->nodeId === -1) {
            $number = mt_rand(0, 1023); // a 10bit number.
            $calc = (($timestamp - 1459440000000) << 22) + ($number << 12) + $rand;
        } else {
            $calc = (($timestamp - 1459440000000) << 22) + ($this->nodeId << 12) + $rand;
        }
        usleep(1);
        return '' . $calc;
    }

    /**
     * It gets the next sequence. If the sequence doesn't exist, it generates a new one with 1.<br>
     * You could peek a sequence with get('genseq_*name*')<br>
     * If the sequence is corrupt then it's resetted.<br>
     *
     * @param string $name              Name of the sequence.
     * @param int    $tries             number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     * @param int    $init              The initial value of the sequence (if it's created)
     * @param int    $interval          The interval between each sequence. It could be negative.
     * @param int    $reserveAdditional Reserve an additional number of sequence. It's useful when you want to generates many sequences at once.
     *
     * @return bool|int It returns false if it fails to lock the sequence or if it's unable to read thr sequence. Otherwise it returns the sequence
     */
    public function getNextSequence($name = "seq", $tries = -1, $init = 1, $interval = 1, $reserveAdditional = 0)
    {
        $id = "genseq_" . $name;
        $file = $this->filename($id) . ".seq";
        if ($this->lock($file, $tries)) {
            if (file_exists($file)) {
                $read = @file_get_contents($file);
                if ($read === false) {
                    $this->unlock($file);
                    return false; // file exists but i am unable to read it.
                }
                $read = (is_numeric($read)) ? ($read + $interval)
                    : $init; // if the value stored is numeric, then we add one, otherwise, it starts with 1
            } else {
                $read = $init;
            }
            $write = @file_put_contents($file, $read + $reserveAdditional, LOCK_EX);
            $this->unlock($file);
            return ($write === false) ? false : $read;
        }

        return false; // unable to lock
    }

    /**
     * Add a document.
     *
     * @param string       $id       Id of the document.
     * @param string|array $document The document
     * @param int          $tries    number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool True if the information was added, otherwise false
     */
    public function insert($id, $document, $tries = -1)
    {
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            if (!file_exists($file)) {
                if ($this->autoSerialize) {
                    $write = @file_put_contents($file, $this->serialize($document), LOCK_EX);
                } else {
                    $write = @file_put_contents($file, $document, LOCK_EX);
                }
            } else {
                $write = false;
            }
            $this->unlock($file);
            return ($write !== false);
        }

        return false;
    }

    /**
     * Add or update a document.
     *
     * @param string       $id       Id of the document.
     * @param string|array $document The document
     * @param int          $tries    number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool True if the information was added, otherwise false
     */
    public function insertOrUpdate($id, $document, $tries = -1)
    {
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            if ($this->autoSerialize) {
                $write = @file_put_contents($file, $this->serialize($document), LOCK_EX);
            } else {
                $write = @file_put_contents($file, $document, LOCK_EX);
            }
            $this->unlock($file);
            return ($write !== false);
        }

        return false;
    }

    /**
     * Update a document
     *
     * @param string       $id       Id of the document.
     * @param string|array $document The document
     * @param int          $tries    number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool True if the information was added, otherwise false
     */
    public function update($id, $document, $tries = -1)
    {
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            if (file_exists($file)) {
                if ($this->autoSerialize) {
                    $write = @file_put_contents($file, $this->serialize($document), LOCK_EX);
                } else {
                    $write = @file_put_contents($file, $document, LOCK_EX);
                }
            } else {
                $write = false;
            }
            $this->unlock($file);
            return ($write !== false);
        }

        return false;
    }

    /**
     * Set the current collection. It also could create the collection.
     *
     * @param      $collection
     * @param bool $createIfNotExist if true then it checks if the collection (folder) exists, if not then it's created
     *
     * @return DocumentStoreOne
     */
    public function collection($collection, $createIfNotExist = false)
    {
        $this->collection = $collection;
        if ($createIfNotExist && !$this->isCollection($collection)) {
            $this->createCollection($collection);
        }
        return $this;
    }

    /**
     * Check a collection
     *
     * @param $collection
     *
     * @return bool It returns false if it's not a collection (a valid folder)
     */
    public function isCollection($collection)
    {
        $this->collection = $collection;
        return is_dir($this->getPath());
    }

    /**
     * Creates a collection
     *
     * @param $collection
     *
     * @return bool true if the operation is right, false if it fails.
     */
    public function createCollection($collection)
    {
        $oldCollection = $this->collection;
        $this->collection = $collection;
        $r = @mkdir($this->getPath());
        $this->collection = $oldCollection;
        return $r;
    }

    /**
     * It sets if we want to auto serialize the information and we set how it is serialized
     *      php = it serializes using serialize() function
     *      php_array = it serializes using include()/var_export() function. The result could be cached on OpCache
     *      json_object = it is serialized using json (as object)
     *      json_array = it is serialized using json (as array)
     *      none = it is not serialized. Information must be serialized/de-serialized manually
     *      php_array = it is serialized as a php_array
     *
     * @param bool   $value
     * @param string $strategy =['php','php_array','json_object','json_array','none'][$i]
     */
    public function autoSerialize($value = true, $strategy = 'php')
    {
        $this->autoSerialize = $value;
        $this->serializeStrategy = $strategy;
    }

    /**
     * List all the Ids in a collection (or returns the documents if $returnOnlyIndex is false)
     *
     * @param string $mask see http://php.net/manual/en/function.glob.php
     *
     * @param bool   $returnOnlyIndex
     *                     If false then it returns each document.
     *                     If returns (default) then it return indexes.
     *
     * @return array|false
     */
    public function select($mask = "*", $returnOnlyIndex = true)
    {
        $list = glob($this->database . "/" . $this->collection . "/" . $mask . $this->docExt);
        foreach ($list as $key => $fileId) {
            $list[$key] = basename($fileId, $this->docExt);
        }
        if ($returnOnlyIndex) {
            return $list;
        }

        $listDoc = [];
        foreach ($list as $fileId) {
            $listDoc[] = $this->get($fileId);
        }
        return $listDoc;
    }

    /**
     * Get a document from the datastore<br>
     * <b>Example:</b><br>
     * <pre>
     * $data=$this->get('rows',-1,false); // it returns a value or false
     * $data=$this->get('rows',-1,"not null"); // it returns a value or "not null" if not found
     * </pre>
     *
     * @param string $id      Id of the document.
     * @param int    $tries   number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     * @param mixed  $default Default value (if the value is not found)
     *
     * @return mixed The object if the information was read, otherwise false (or default value).
     */
    public function get($id, $tries = -1, $default = false)
    {
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            if ($this->serializeStrategy === 'php_array') {
                $json = @include $file;
                $this->unlock($file);
            } else {
                $json = @file_get_contents($file);
                $this->unlock($file);
                if (strpos($json, $this->separatorAppend) === false) {
                    if ($this->autoSerialize) {
                        $json = $this->deserialize($json);
                    }
                } else {
                    $arr = explode($this->separatorAppend, $json);
                    if (count($arr) > 0 && $arr[0] === '') {
                        unset($arr[0]);
                    }
                    $json = [];
                    foreach ($arr as $item) {
                        $json[] = $this->deserialize($item);
                    }
                }
            }
            return ($json === false) ? $default : $json;
        }
        return $default;
    }

    private function deserialize($document)
    {
        switch ($this->serializeStrategy) {
            // php_array should be included.
            //case 'php_array':
            //    return self::serialize_php_array($document);
            case 'php':
                return unserialize($document);
            case 'json_object':
                return json_decode($document, false);
            case 'json_array':
                return json_decode($document, true);
            default:
                // also for none
                return $document;
        }
    }

    /**
     * It gets a values from the datastore filtered by a condition<br>
     * <b>Example:</b><br>
     * <pre>
     * $data=$this->getFiltered('rows',-1,false,['type'=>'busy']); // it returns values [0=>...,1=>...]
     * $data=$this->getFiltered('rows',-1,false,['type'=>'busy'],false); // it returns values [2=>...,4=>..]
     * </pre>
     *
     * @param string $id        Id of the document.
     * @param int    $tries     number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     * @param mixed  $default   default value (if the value is not found)
     * @param array  $condition An associative array with the conditions.
     * @param bool   $reindex   If true then the result is reindexed (starting from zero).
     *
     * @return array
     */
    public function getFiltered($id, $tries = -1, $default = false, $condition = [], $reindex = true)
    {
        $rows = $this->get($id, $tries, $default);
        $result = [];
        foreach ($rows as $k => $v) {
            $fail = false;
            foreach ($condition as $k2 => $v2) {
                if (is_object($v)) {
                    if (!isset($v->{$k2}) || $v->{$k2} != $v2) {
                        $fail = true;
                        break;
                    }
                } elseif (!isset($v[$k2]) || $v[$k2] != $v2) {
                    $fail = true;
                    break;
                }
            }
            if (!$fail) {
                if ($reindex) {
                    $result[] = $rows[$k];
                } else {
                    $result[$k] = $rows[$k];
                }
            }
        }
        return $result;

    }

    /**
     * Return if the document exists. It doesn't check until the document is fully unlocked unless $tries=null
     *
     * @param string   $id    Id of the document.
     * @param int|null $tries number of tries.<br>
     *                        The default value is -1 (it uses the default value $defaultNumRetry)<br>
     *                        If $tries=null then it never check the lock.
     *
     * @return string|bool True if the information was read, otherwise false.
     */
    public function ifExist($id, $tries = -1)
    {
        $file = $this->filename($id);
        if ($tries!==null) {
            if ($this->lock($file, $tries)) {
                $exist = file_exists($file);
                $this->unlock($file);
                return $exist;
            }
        } else {
            return file_exists($file);
        }

        return false;
    }

    /**
     * Delete a document.
     *
     * @param string $id    Id of the document
     * @param int    $tries number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool if it's unable to unlock or the document doesn't exist.
     */
    public function delete($id, $tries = -1)
    {
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            $r = @unlink($file);
            $this->unlock($file);
            return $r;
        }
        
        return false;
    }

    /**
     * Copy a document. If the destination exists, it's replaced.
     *
     * @param string $idOrigin
     * @param string $idDestination
     * @param int    $tries number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool true if the operation is correct, otherwise it returns false (unable to lock / unable to copy)
     */
    public function copy($idOrigin, $idDestination, $tries = -1)
    {
        $fileOrigin = $this->filename($idOrigin);
        $fileDestination = $this->filename($idDestination);
        if ($this->lock($fileOrigin, $tries)) {
            if ($this->lock($fileDestination, $tries)) {
                $r = @copy($fileOrigin, $fileDestination);
                $this->unlock($fileOrigin);
                $this->unlock($fileDestination);
                return $r;
            }

            $this->unlock($fileOrigin);
            return false;
        }

        return false;
    }

    /**
     * Rename a document. If the destination exists, it's not renamed
     *
     * @param string $idOrigin
     * @param string $idDestination
     * @param int    $tries number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool true if the operation is correct, otherwise it returns false
     *              (unable to lock / unable to rename)
     */
    public function rename($idOrigin, $idDestination, $tries = -1)
    {
        $fileOrigin = $this->filename($idOrigin);
        $fileDestination = $this->filename($idDestination);
        if ($this->lock($fileOrigin, $tries)) {
            if ($this->lock($fileDestination, $tries)) {
                $r = @rename($fileOrigin, $fileDestination);
                $this->unlock($fileOrigin);
                $this->unlock($fileDestination);
                return $r;
            }

            $this->unlock($fileOrigin);
            return false;
        }

        return false;
    }

}

