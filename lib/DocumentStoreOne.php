<?php
/**
 * @noinspection PhpParameterByRefIsNotUsedAsReferenceInspection
 * @noinspection UnknownInspectionInspection
 */

namespace eftec\DocumentStoreOne;

use DateTime;
use Exception;
//use Memcache;
use Redis;
use ReflectionObject;
use RuntimeException;

/**
 * Class DocumentStoreOne
 *
 * @version 1.19 2021-12-08
 * @author  Jorge Castro Castillo jcastro@eftec.cl
 * @link    https://github.com/EFTEC/DocumentStoreOne
 * @license LGPLv3 and commercial
 */
class DocumentStoreOne
{

    const DSO_AUTO = 'auto';
    const DSO_FOLDER = 'folder';
    const DSO_APCU = 'apcu';
    /*const DSO_MEMCACHE = 'memcached';*/
    const DSO_REDIS = 'redis';
    const DSO_NONE = 'none';
    /**
     * @var string It is used to append a value without updating the whole file.
     *             This value must be enough complex to avoid collisions.
     *             But it is also must be utf-8 compatible.
     *             10 x 8 bits = 80 bits (1,208,925,819,614,629,174,706,176 chances of colision)
     */
    public $separatorAppend = "~§¶¤¶¤¶§~\n";
    /** @var mixed $currentId The id of the current document */
    public $currentId;
    /** @var string root folder of the database */
    public $database;
    /** @var string collection (subfolder) of the database */
    public $collection;
    /** @var int Maximium duration of the lock (in seconds). By default it's 2 minutes */
    public $maxLockTime = 120;
    /** @var int Default number of retries. By default it tries 100x0.1sec=10 seconds */
    public $defaultNumRetry = 100;
    /** @var int Interval (in microseconds) between retries. 100000 means 0.1 seconds */
    public $intervalBetweenRetry = 100000;
    /** @var string Default extension (with dot) of the document */
    public $docExt = ".dson";
    /** @var string=['php','php_array','json_object','json_array','csv','none'][$i] */
    public $serializeStrategy = 'php';
    /** @var bool if true then it will never lock or unlock the document. It is useful for a read only base */
    public $neverLock = false;
    /** @var int DocumentStoreOne::DSO_* */
    public $strategy = self::DSO_FOLDER;
    public $csvSeparator = ',';
    public $csvText = '"';
    public $csvEscape = '\\';
    public $csvHeader = true;
    public $csvLineEnd = "\n";
    /**
     * @var string If the column is missing, then it creates a name of a column, otherwise the name of the columns is
     *             the number of the column
     */
    public $csvPrefixColumn = '';
    public $regionDecimal = '.';
    public $regionDateTime = 'Y-m-d H:i:s';
    public $regionDate = 'Y-m-d';
    /** @var array=[]['auto','int','decimal','datetime','string][$i] */
    public $schemas;
    private $tabular = false;
    /** @var Redis */
    public $redis;
    /** @var string=['','md5','sha1','sha256','sha512'][$i] Indicates if the key is encrypted or not when it's stored (the file name). Empty means, no encryption. You could use md5,sha1,sha256,.. */
    public $keyEncryption = '';
    /**
     * @var int nodeId It is the identifier of the node.<br>
     * It must be between 0..1023<br>
     * If the value is -1, then it randomizes it's value each call.
     */
    public $nodeId = 1;
    private $autoSerialize;
    public $throwable=true;
    public $latestError='';
    /*private $memcache;*/
    /**
     * @var string= 'sequencephp' (snowfake generation),'nextsequence' (generated by a document) or the name of the
     *      field.
     */
    private $objectIndex;

    /**
     * DocumentStoreOne constructor.<br>
     * <b>Example</b>:
     * <pre>
     * $obj=new DocumentStoreOne(__DIR__."/base",'collectionFolder');
     * </pre>
     *
     * @param string      $database          root folder of the database
     * @param string      $collection        collection (subfolder) of the database. If the collection is empty then it
     *                                       uses the root folder.
     * @param string      $strategy          =['auto','folder','apcu','redis','none'][$i] The strategy is
     *                                       only used to lock/unlock purposes.
     * @param string      $server            Used for 'redis' (localhost:6379)
     * @param bool|string $serializeStrategy =['php','php_array','json_object','json_array','csv','none'][$i]
     *                                       It sets the strategy of serialization<br>
     *                                       If false then the value (inserted) is auto serialized<br>
     * @param string      $keyEncryption     =['','md5','sha1','sha256','sha512'][$i] it uses to encrypt the name of
     *                                       the keys
     *                                       (filename)
     *
     * @throws RuntimeException
     * @example $flatcon=new DocumentStoreOne(__DIR__."/base",'collectionFolder');
     */
    public function __construct(
        $database,
        $collection = '',
        $strategy = 'auto',
        $server = "",
        $serializeStrategy = false,
        $keyEncryption = ''
    )
    {
        $this->database = $database;
        $this->collection = $collection;
        if($serializeStrategy===false) {
            $this->autoSerialize=false;
        } else if($serializeStrategy===true) {
            // it is for old compatibility
            $this->autoSerialize=true;
        } else {
            $this->autoSerialize(true, $serializeStrategy);
        }
        $this->keyEncryption = $keyEncryption;

        //$r=$memcache->connect(MEMCACHE_SERVER, MEMCACHE_PORT);
        $this->setStrategy($strategy, $server);

        if (!is_dir($this->getPath())) {
            $this->throwError("the folder is incorrect or I'm not unable to read  it: "
                . $this->getPath() .
                '. You could create the collection with createCollection()');
        }
    }

    public function isTabular()
    {
        return $this->tabular;
    }

    /**
     * It sets the strategy to lock and unlock the folders
     *
     * @param string|int $strategy =['auto','folder','apcu','memcached','redis','none'][$i]
     * @param string     $server
     *
     * @throws RuntimeException
     * @noinspection ClassConstantCanBeUsedInspection
     */
    public function setStrategy($strategy, $server = "")
    {
        if ($strategy === self::DSO_AUTO) {
            if (function_exists('apcu_add')) {
                $this->strategy = self::DSO_APCU;
            //} elseif (class_exists('\Memcache')) {
            //    $this->strategy = self::DSO_MEMCACHE;
            } else {
                $this->strategy = self::DSO_FOLDER;
            }
            $strategy = $this->strategy;
        } else {
            $this->strategy = $strategy;
        }
        switch ($strategy) {
            case self::DSO_NONE:
            case self::DSO_FOLDER:
                break;
            case self::DSO_APCU:
                if (!function_exists("apcu_add")) {
                    $this->throwError('APCU is not defined');
                    return;
                }
                break;
            /*case self::DSO_MEMCACHE:
                if (!class_exists("\Memcache")) {
                    throw new RuntimeException("Memcache is not defined");
                }
                $this->memcache = new Memcache();
                $host = explode(':', $server);
                $r = @$this->memcache->pconnect($host[0], $host[1]);
                if (!$r) {
                    throw new RuntimeException("Memcache is not open");
                }
                break;*/
            case self::DSO_REDIS:
                /** @noinspection ClassConstantCanBeUsedInspection */
                if (!class_exists("\Redis")) {
                    $this->throwError('Redis is not defined');
                    return;
                }
                if (function_exists('cache')) {
                    $this->redis = cache();// inject using the cache function (if any).
                } else {
                    $this->redis = new Redis();
                    $host = explode(':', $server);
                    $r = @$this->redis->pconnect($host[0], $host[1], 30); // 30 seconds timeout
                    if (!$r) {
                        $this->throwError('Unable to open Redis, check the server and connections.');
                        return;
                    }
                }
                break;
            default:
                $this->throwError("Strategy not defined");
        }
    }

    /**
     * It gets the current path.
     *
     * @return string
     */
    private function getPath()
    {
        return $this->database . "/" . $this->collection;
    }

    /**
     * Util function to fix the cast of an object.
     * Usage utilCache::fixCast($objectRightButEmpty,$objectBadCast);
     *
     * @param object|array $destination Object may be empty with the right cast.
     * @param object|array $source      Object with the wrong cast.
     *
     * @return void
     */
    public static function fixCast(&$destination, $source)
    {
        if (is_array($source)) {
            $getClass = get_class($destination[0]);
            $array = array();
            foreach ($source as $sourceItem) {
                $obj = new $getClass();
                self::fixCast($obj, $sourceItem);
                $array[] = $obj;
            }
            $destination = $array;
        } else {
            $sourceReflection = new ReflectionObject($source);
            $sourceProperties = $sourceReflection->getProperties();
            foreach ($sourceProperties as $sourceProperty) {
                $name = $sourceProperty->getName();
                if (is_object(@$destination->{$name})) {
                    if (get_class(@$destination->{$name}) === "DateTime") {
                        // source->name is a stdclass, not a DateTime, so we could read the value with the field date
                        try {
                            $destination->{$name} = new DateTime($source->$name->date);
                        } catch (Exception $e) {
                            $destination->{$name} = null;
                        }
                    } else {
                        self::fixCast($destination->{$name}, $source->$name);
                    }
                } else {
                    $destination->{$name} = $source->$name;
                }
            }
        }
    }

    /**
     * Set if we need to lock/unlock every time we want to read/write a value
     *
     * @param bool $neverLock if its true then the register is never locked. It is fast but it's not concurrency-safe
     */
    public function setNeverLock($neverLock = true)
    {
        $this->neverLock = $neverLock;
    }

    /**
     * It appends a value to an existing document. It creates an array of values if it doesn't exists.<br>
     * <b>Example:</b>
     * <pre>
     * $this->appendvalue('20',[1,2,3]); // document "20" = [[1,2,3]]
     * $this->appendvalue('20',[3,4,5]); // document "20" = [[1,2,3],[3,4,5]]
     * </pre>
     *
     *
     * @param string $id       id of the document.
     * @param mixed  $addValue This value could be serialized.
     * @param int    $tries    number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool It returns false if it fails to lock the document or if it's unable to read the document. Otherwise
     *              it returns true
     * @throws RuntimeException
     */
    public function appendValue($id, $addValue, $tries = -1)
    {
        $this->currentId = $id;
        /*if ($this->serializeStrategy === 'php_array') {
            throw new RuntimeException('appendValue doesn't work with php_array');
        }*/
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            switch ($this->serializeStrategy) {
                case 'json_array':
                case 'json_object':
                case 'php_array':
                case 'csv':
                    if ($this->ifExist($id, null)) {
                        $fp = @fopen($file, 'rb+');
                    } else {
                        $this->unlock($file);
                        return $this->insert($id, [$addValue], $tries);
                    }
                    if ($fp === false) {
                        $this->unlock($file);
                        $this->throwError(error_get_last());
                        return false; // file exists but I am unable to open it.
                    }
                    switch ($this->serializeStrategy) {
                        case 'csv':
                            fseek($fp, 0, SEEK_END);
                            $addValue = $this->serialize($addValue, true); // true no add header
                            $r = @fwrite($fp, $addValue);
                            break;
                        case 'php_array':
                            fseek($fp, -4, SEEK_END);
                            $addValue = $this->serialize($addValue, true);
                            $r = @fwrite($fp, ',' . $addValue . ");\n "); //note: ");\n " it must be exactly 4 characters.
                            break;
                        default:
                            fseek($fp, -1, SEEK_END);
                            $addValue = $this->serialize($addValue, true);
                            $r = @fwrite($fp, ',' . $addValue . ']');
                    }
                    @fclose($fp);
                    $this->unlock($file);
                    if($r===false) {
                        $this->throwError(error_get_last());
                    }
                    return ($r !== false);

                default:
                    $fp = @fopen($file, 'ab');
                    if ($fp === false) {
                        $this->unlock($file);
                        $this->throwError(error_get_last());
                        return false; // file exists but I am unable to open it.
                    }
                    $addValue = $this->serialize($addValue);
                    $addValue = $this->separatorAppend . $addValue;
                    $r = @fwrite($fp, $addValue);
                    @fclose($fp);
                    $this->unlock($file);
                    if($r===false) {
                        $this->throwError(error_get_last());
                    }
                    return ($r !== false);
            }

        }
        $this->throwError("unable to lock file [$this->currentId]");
        return false; // unable to lock
    }

    /**
     * Convert Id to a full filename. If keyencryption then the name is encrypted.
     *
     * @param string $id
     *
     * @return string full filename
     */
    private function filename($id)
    {
        $file = $this->keyEncryption ? hash($this->keyEncryption, $id) : $id;
        return $this->getPath() . "/" . $file . $this->docExt;
    }

    /**
     * It locks a file
     *
     * @param     $filepath
     * @param int $maxRetry
     *
     * @return bool
     */
    private function lock($filepath, $maxRetry = -1)
    {
        if ($this->neverLock) {
            return true;
        }
        $maxRetry = ($maxRetry === -1) ? $this->defaultNumRetry : $maxRetry;
        switch ($this->strategy) {
            case self::DSO_APCU:
                $try = 0;
                while (@apcu_add("documentstoreone." . $filepath, 1, $this->maxLockTime) === false && $try < $maxRetry) {
                    $try++;
                    usleep($this->intervalBetweenRetry);
                }
                return ($try < $maxRetry);
            /*case self::DSO_MEMCACHE:
                $try = 0;
                while (@$this->memcache->add("documentstoreone." . $filepath, 1, 0, $this->maxLockTime) === false
                    && $try < $maxRetry) {
                    $try++;
                    usleep($this->intervalBetweenRetry);
                }
                return ($try < $maxRetry);*/
            case self::DSO_REDIS:
                $try = 0;
                while (@$this->redis->set("documentstoreone." . $filepath, 1, ['NX', 'EX' => $this->maxLockTime]) !==
                    true
                    && $try < $maxRetry) {
                    $try++;
                    usleep($this->intervalBetweenRetry);
                }
                return ($try < $maxRetry);
            case self::DSO_FOLDER:
                clearstatcache();

                $lockname = $filepath . ".lock";
                $life = @filectime($lockname); // $life=false is ok (the file doesn't exist)
                $try = 0;
                while (!@mkdir($lockname) && is_dir($lockname) && $try < $maxRetry) {
                    $try++;
                    if ($life && (time() - $life) > $this->maxLockTime) {
                        rmdir($lockname);
                        $life = false;
                    }
                    usleep($this->intervalBetweenRetry);
                }
                return ($try < $maxRetry);
            case self::DSO_NONE:
                return true;
        }
        return false;
    }

    /**
     * Return if the document exists. It doesn't check until the document is fully unlocked unless $tries=null
     *
     * @param string   $id    Id of the document.
     * @param int|null $tries number of tries.<br>
     *                        The default value is -1 (it uses the default value $defaultNumRetry)<br>
     *                        If $tries=null then it never check the lock.
     *
     * @return bool True if the information was read, otherwise false.
     */
    public function ifExist($id, $tries = -1)
    {
        $file = $this->filename($id);
        if ($tries !== null) {
            if ($this->lock($file, $tries)) {
                $exist = file_exists($file);
                $this->unlock($file);
                return $exist;
            }
        } else {
            return file_exists($file);
        }
        return false;
    }

    /**
     * Unlocks a document
     *
     * @param string $filepath full file path/key of the document to unlock.
     *
     * @return bool returns true if the unlocks works. Otherwise, it returns false.
     * @noinspection PhpReturnValueOfMethodIsNeverUsedInspection
     */
    private function unlock($filepath)
    {
        if ($this->neverLock) {
            return true;
        }
        switch ($this->strategy) {
            case self::DSO_APCU:
                return apcu_delete("documentstoreone." . $filepath);
            /*case self::DSO_MEMCACHE:
                return $this->memcache->delete("documentstoreone." . $filepath);*/
            case self::DSO_REDIS:
                return ($this->redis->del("documentstoreone." . $filepath) > 0);
            case self::DSO_NONE:
                return true;
        }
        $unlockname = $filepath . ".lock";
        $try = 0;
        // retry to delete the unlockname folder. If fails then it tries it again.
        while (!@rmdir($unlockname) && $try < $this->defaultNumRetry) {
            $try++;
            usleep($this->intervalBetweenRetry);
        }
        return ($try < $this->defaultNumRetry);
    }

    /**
     * Add a document.
     *
     * @param string       $id       Id of the document.
     * @param string|array $document The document
     * @param int          $tries    number of tries. The default value is -1 (it uses the default value
     *                               $defaultNumRetry)
     *
     * @return bool True if the information was added, otherwise false
     */
    public function insert($id, $document, $tries = -1)
    {
        $file = $this->filename($id);
        $this->currentId = $id;
        if ($this->lock($file, $tries)) {
            if(!isset($document[0]) && $this->tabular) {
                $write=false;
                $errorLast='Data is not tabular';
            } else if (!file_exists($file)) {
                if ($this->autoSerialize) {
                    if ($this->serializeStrategy === 'csv') {
                        $this->getHeaderCSV($document);
                        $this->determineTypes($document[0]);
                    }
                    // note: for the csv, it includes the header (if the csv uses headers)
                    $write = @file_put_contents($file, $this->serialize($document), LOCK_EX);
                } else {
                    $write = @file_put_contents($file, $document, LOCK_EX);
                }
                $errorLast=@error_get_last();
            } else {
                $write = false;
                $errorLast="File does exist [$this->currentId]. Unable to override file";
            }
            if($write===false) {
                @$this->unlock($file);
                $this->throwError($errorLast);
                return false;
            }
            $this->unlock($file);
            return true;
        }
        $this->unlock($file);
        $this->throwError("Unable to lock file [$this->currentId]");
        return false;
    }

    /**
     * @param mixed $document The document content to serialize.
     * @param bool  $special  used by serialize_php_array() and serializeCSV()
     *
     * @return string
     */
    private function serialize($document, $special = false)
    {
        switch ($this->serializeStrategy) {
            case 'php_array':
                return self::serialize_php_array($document, $special);
            case 'php':
                return serialize($document);
            case 'json_object':
            case 'json_array':
                return json_encode($document);
            case 'csv':
                // special true = no header
                // special false = header
                return $this->serializeCSV($document, $special);
            default:
                // also for none
                return $document;
        }
    }


    //region csv

    /**
     * It gets the header of a csv only if the id of the document doesn't have it.
     *
     * @param array $table
     * @return void
     */
    private function getHeaderCSV($table)
    {
        if (!isset($this->schemas[$this->currentId])) {
            if (!$this->isTable($table)) {
                // it just a row, so we convert into a row.
                $table = [$table];
            }
            $this->schemas[$this->currentId] = [];
            foreach ($table[0] as $kcol => $v) {
                if (is_numeric($kcol)) {
                    $kcol = $this->csvPrefixColumn . $kcol;
                }
                $this->schemas[$this->currentId][$kcol] = 'string'; // default value is string
            }
        }
    }

    /**
     * Returns true if the input is a table (a 2 dimensional array)
     * @param mixed $table
     * @return bool
     */
    private function isTable(&$table)
    {
        return isset($table[0]) && is_array($table[0]);
    }

    private function splitLine($lineTxt, $useColumn)
    {
        if ($lineTxt === null || $lineTxt === '') {
            return [];
        }
        $arr = str_getcsv($lineTxt, $this->csvSeparator, $this->csvText,$this->csvEscape);
        $result = [];
        if ($useColumn === true) {
            $colnames = isset($this->schemas[$this->currentId]) ? array_keys($this->schemas[$this->currentId]) : [];
            foreach ($arr as $numCol => $v) {
                if (!isset($colnames[$numCol])) {
                    $colnames[$numCol] = $this->csvPrefixColumn . $numCol;
                    $this->schemas[$this->currentId][$colnames[$numCol]] = $this->getType($v); // column is missing so we create a column name
                }
                $result[$colnames[$numCol]] = trim($v);

            }
        } else {
            foreach ($arr as $k => $v) {
                $result[$k] = trim($v);
            }
        }
        return $result;
    }

    public function getType($input)
    {
        // array
        if (is_array($input)) {
            return 'array';
        }
        // int?
        if ($this->isInt($input)) {
            return 'int';
        }
        // decimal?
        if ($this->regionDecimal !== '.') {
            $inputD = str_replace($this->regionDecimal, '.', $input);
        } else {
            $inputD = $input;
        }
        if (is_numeric($inputD)) {
            return 'decimal';
        }
        // datetime?
        $inputD = ($input instanceof DateTime) ? $input : DateTime::createFromFormat($this->regionDateTime, $input);
        if ($inputD instanceof DateTime) {
            return 'datetime';
        }
        // date
        $inputD = DateTime::createFromFormat($this->regionDate, $input);
        if ($inputD instanceof DateTime) {
            return 'date';
        }
        return is_string($input) ? 'string' : 'oobject';
    }

    public function isInt($input)
    {
        if ($input === null || $input === '') {
            return false;
        }
        if (is_int($input)) {
            return true;
        }
        if (is_float($input) || is_object($input)) {
            return false;
        }
        if ($input[0] === '-') {
            return ctype_digit(substr($input, 1));
        }
        return ctype_digit($input);
    }

    private function serializeCSV($table, $noheader = false)
    {
        $result = '';
        if (!$noheader && $this->csvHeader) {
            // had header
            $line = [];
            foreach ($this->schemas[$this->currentId] as $colname => $type) {
                $line[] = $this->convertTypeBack($colname, 'string');
            }
            $result = implode($this->csvSeparator, $line) . $this->csvLineEnd;
        }
        $line = [];
        if (!$this->isTable($table)) {
            // it just a row, so we convert into a row.
            $table = [$table];
        }
        foreach ($table as $kr => $row) {
            foreach ($row as $kcol => $v) {
                $line[$kr][$kcol] = $this->convertTypeBack($v, $this->schemas[$this->currentId][$kcol]);
            }
            $result .= implode($this->csvSeparator, $line[$kr]) . $this->csvLineEnd;
        }
        return $result;
    }

    public function convertTypeBack($input, $type)
    {
        switch ($type) {
            case 'int':
                return $input;
            case 'decimal':
                if ($this->regionDecimal !== '.') {
                    $inputD = str_replace('.', $this->regionDecimal, $input);
                } else {
                    $inputD = $input;
                }
                return $inputD;
            case 'date':
                if ($this->serializeStrategy === 'csv') {
                    return $this->csvText . $input->format($this->regionDate) . $this->csvText;
                }
                return $input->format($this->regionDate);
            case 'string':
                if ($this->serializeStrategy === 'csv') {
                    if($this->csvText && strpos($input,$this->csvText)) {
                        return $this->csvText .str_replace($this->csvText,$this->csvEscape.$this->csvText,$input) . $this->csvText;
                    }
                    return $this->csvText .$input . $this->csvText;

                }
                return $input;
            case 'datetime':
                if ($this->serializeStrategy === 'csv') {
                    return $this->csvText . $input->format($this->regionDateTime) . $this->csvText;
                }
                return $input->format($this->regionDateTime);
        }
        return $input;
    }

    public function convertType($input, $type)
    {
        switch ($type) {
            case 'int':
                return (int)$input;
            case 'decimal':
                if ($this->regionDecimal !== '.') {
                    $inputD = str_replace($this->regionDecimal, '.', $input);
                } else {
                    $inputD = $input;
                }
                return (float)$inputD;
            case 'string':
                if(!$this->csvEscape || strpos($input,$this->csvEscape)===false) {
                    return (string)$input;
                }
                return (string)str_replace($this->csvEscape,'',$input);
            case 'date':
                return DateTime::createFromFormat($this->regionDate, $input);
            case 'datetime':
                return DateTime::createFromFormat($this->regionDateTime, $input);
        }
        return $input;
    }

    private function unserializeCSV(&$document)
    {
        $lines = explode($this->csvLineEnd, $document);
        $result = [];
        $numLines = count($lines);
        if ($numLines > 0) {
            if ($this->csvHeader) {
                // it has header
                $header = $this->splitLine($lines[0], false);
                foreach ($header as $namecol) {
                    $this->schemas[$this->currentId][$namecol] = 'string';
                }
                $first = 1;
            } else {
                // no header
                $this->schemas[$this->currentId] = null;
                $first = 0;
            }
            if (isset($lines[$first])) {
                // asume types
                $firstLine = $this->splitLine($lines[$first], true);
                //$numcols=count($firstLine);
                $this->determineTypes($firstLine);
                for ($i = $first; $i < $numLines; $i++) {
                    $tmp = $this->splitLine($lines[$i], true);
                    foreach ($tmp as $namecol => $item) {
                        if (!isset($this->schemas[$this->currentId][$namecol])) {
                            $this->throwError('incorrect column found in csv line ' . $i);
                            return null;
                        }
                        $tmp[$namecol] = $this->convertType($item, $this->schemas[$this->currentId][$namecol]);
                    }
                    if (count($tmp) > 0) {
                        // we avoid inserting an empty line
                        $result[] = $tmp;
                    }
                }
            }
        }
        return $result;
    }

    /**
     * @param array $row is an associative array with the values to determine
     * @return void
     */
    private function determineTypes(&$row)
    {
        $cols = isset($this->schemas[$this->currentId]) ? $this->schemas[$this->currentId] : null;
        // $this->schemas[$this->currentId] = [];
        if ($cols === null) {
            // there is no columns defined, so we define columns using this row
            foreach ($row as $kcol => $item) {
                if (is_numeric($kcol)) {
                    $kcol = $this->csvPrefixColumn . $kcol;
                }
                $this->schemas[$this->currentId][$kcol] = $this->getType($item);
            }
        } else {
            $c = -1;
            foreach ($cols as $kcol => $v) {
                if (isset($row[0])) {
                    $c++;
                    $this->schemas[$this->currentId][$kcol]
                        = $this->getType($row[$c]);
                } else {
                    $this->schemas[$this->currentId][$kcol]
                        = $this->getType($row[$kcol]);
                }
            }
        }
    }

    //endregion

    private static function serialize_php_array($document, $special = false)
    {
        if ($special) {
            // for append
            return var_export($document, true);
        }
        return "<?php /** @generated */\nreturn " . var_export($document, true) . ';';

    }

    /**
     * It sets the default object field used for index.
     *
     * @param string $indexField
     */
    public function setObjectIndex($indexField)
    {
        $this->objectIndex = $indexField;
    }

    /**
     * It inserts (or update) an associative array or an object into the document store<br>
     * Example:<br>
     * $obj=['id'=>1,'name'=>'john'];<br>
     * $doc->insertOrUpdateObject($obj,'id');<br>
     *
     * @param array|object $object     The object (or associative array) to store
     * @param null|string  $indexField =['sequencephp','nextsequence'][$i]<br>
     *                                 if null then it uses the default index field defined by setObjectIndex()<br>
     *                                 if sequencephp then it uses snowflake for generate a new sequence<br>
     *                                 if nextsequence then it uses a document sequence<br>
     *
     * @return string the index value
     * @see \eftec\DocumentStoreOne\DocumentStoreOne::setObjectIndex
     */
    public function insertOrUpdateObject($object, $indexField = null)
    {
        return $this->insertObject($object, $indexField, 'insertorupdate');
    }

    /**
     * It inserts an associative array or an object into the document store
     *
     * @param array|object $object     The object to store
     * @param null|string  $indexField =['sequencephp','nextsequence'][$i]<br>
     *                                 if null then it uses the default index field defined by setObjectIndex()<br>
     *                                 if sequencephp then it uses snowflake for generate a new sequence<br>
     *                                 if nextsequence then it uses a document sequence<br>
     *                                 if the value is tabular, then it uses the first row to find the id<br>
     *
     * @param string       $operation  =['insert','insertorupdate'][$i]
     *
     * @return string the index value
     * @see \eftec\DocumentStoreOne\DocumentStoreOne::setObjectIndex
     */
    public function insertObject($object, $indexField = null, $operation = 'insert')
    {
        if ($indexField === null) {
            $indexField = $this->objectIndex;
        }
        switch ($indexField) {
            case 'sequencephp':
                $idx = $this->getSequencePHP();
                break;
            case 'nextsequence':
                $idx = $this->getNextSequence();
                break;
            default:
                $idx = $indexField;
                if($this->tabular && isset($object[0])) {
                    $idx = is_object($object[0]) ? $object[0]->{$idx} : $object[0][$idx];
                } else {
                    $idx = is_object($object) ? $object->{$idx} : $object[$idx];
                }

        }
        try {
            switch ($operation) {
                case 'insert':
                    $this->insert($idx, $object);
                    break;
                case 'insertorupdate':
                    $this->insertOrUpdate($idx, $object);
                    break;
                default:
                    trigger_error('insertObject: operation not defined');
            }
            return $idx;
        } catch (Exception $ex) {
            $this->throwError($ex->getMessage());
            return false;
        }
    }

    public function throwError($msg) {
        if($this->throwable) {
            if(is_array($msg)) {
                throw @new RuntimeException("{$msg['message']} file:{$msg['file']}[{$msg['line']}]",$msg['type']);
            }
            throw new RuntimeException($msg);
        }
        $this->latestError=$msg;
    }
    public function lastError() {
        return $this->latestError;
    }
    public function resetError() {
        $this->latestError='';
    }

    /**
     * <p>This function returns an unique sequence<p>
     * It ensures a collision free number only if we don't do more than one operation
     * per 0.0001 second However,it also adds a pseudo random number (0-4095)
     * so the chances of collision is 1/4095 (per two operations executed every 0.0001 second).<br>
     * It is based on Twitter's Snowflake number.
     *
     * @return string (it returns a 64bit integer).
     */
    public function getSequencePHP()
    {
        $ms = microtime(true); // we use this number as a random number generator (we use the decimals)
        //$ms=1000;
        $timestamp = round($ms * 1000);
        $rand = (fmod($ms, 1) * 1000000) % 4096; // 4096= 2^12 It is the millionth of seconds
        if ($this->nodeId === -1) {
            $number = mt_rand(0, 1023); // a 10bit number.
            $calc = (($timestamp - 1459440000000) << 22) + ($number << 12) + $rand;
        } else {
            $calc = (($timestamp - 1459440000000) << 22) + ($this->nodeId << 12) + $rand;
        }
        usleep(1);
        return '' . $calc;
    }

    /**
     * It gets the next sequence. If the sequence doesn't exist, it generates a new one with 1.<br>
     * You could peek a sequence with get('genseq_*name*')<br>
     * If the sequence is corrupt then it's resetted.<br>
     *
     * @param string $name              Name of the sequence.
     * @param int    $tries             number of tries. The default value is -1 (it uses the default value
     *                                  $defaultNumRetry)
     * @param int    $init              The initial value of the sequence (if it's created)
     * @param int    $interval          The interval between each sequence. It could be negative.
     * @param int    $reserveAdditional Reserve an additional number of sequence. It's useful when you want to
     *                                  generates many sequences at once.
     *
     * @return bool|int It returns false if it fails to lock the sequence or if it's unable to read thr sequence.
     *                  Otherwise, it returns the sequence
     */
    public function getNextSequence($name = "seq", $tries = -1, $init = 1, $interval = 1, $reserveAdditional = 0)
    {
        $id = "genseq_" . $name;
        $file = $this->filename($id) . ".seq";
        if ($this->lock($file, $tries)) {
            if (file_exists($file)) {
                $read = @file_get_contents($file);
                if ($read === false) {
                    $this->unlock($file);
                    $this->throwError(error_get_last());
                    return false; // file exists but I am unable to read it.
                }
                $read = (is_numeric($read)) ? ($read + $interval)
                    : $init; // if the value stored is numeric, then we add one, otherwise, it starts with 1
            } else {
                $read = $init;
            }
            $write = @file_put_contents($file, $read + $reserveAdditional, LOCK_EX);
            $this->unlock($file);
            if($write===false) {
                $this->throwError(error_get_last());
            }
            return ($write === false) ? false : $read;
        }

        return false; // unable to lock
    }

    /**
     * Add or update a whole document.
     *
     * @param string       $id       Id of the document.
     * @param string|array $document The document
     * @param int          $tries    number of tries. The default value is -1 (it uses the default value
     *                               $defaultNumRetry)
     *
     * @return bool True if the information was added, otherwise false
     */
    public function insertOrUpdate($id, $document, $tries = -1)
    {
        $file = $this->filename($id);
        $this->currentId = $id;
        if ($this->lock($file, $tries)) {
            if ($this->autoSerialize) {
                if ($this->serializeStrategy === 'csv') {
                    $this->getHeaderCSV($document);
                    $this->determineTypes($document[0]);
                }
                $write = @file_put_contents($file, $this->serialize($document), LOCK_EX);
            } else {
                $write = @file_put_contents($file, $document, LOCK_EX);
            }
            $this->unlock($file);
            if($write===false) {
                $this->throwError(error_get_last());
            }
            return ($write !== false);
        }

        $this->throwError("Unable to lock file [$this->currentId]");
        return false;
    }

    /**
     * Update a whole document
     *
     * @param string       $id       Id of the document.
     * @param string|array $document The document
     * @param int          $tries    number of tries. The default value is -1 (it uses the default value
     *                               $defaultNumRetry)
     *
     * @return bool True if the information was added, otherwise false
     */
    public function update($id, $document, $tries = -1)
    {
        $file = $this->filename($id);
        $this->currentId = $id;
        if ($this->lock($file, $tries)) {
            if (file_exists($file)) {
                if ($this->autoSerialize) {
                    $write = @file_put_contents($file, $this->serialize($document), LOCK_EX);
                } else {
                    $write = @file_put_contents($file, $document, LOCK_EX);
                }
            } else {
                $write = false;
            }
            $this->unlock($file);
            if($write===false) {
                $this->throwError(error_get_last());
            }
            return ($write !== false);
        }
        $this->throwError("Unable to lock file [$this->currentId]");
        return false;
    }

    /**
     * Set the current collection. It also could create the collection.
     *
     * @param      $collection
     * @param bool $createIfNotExist if true then it checks if the collection (folder) exists, if not then it's created
     *
     * @return DocumentStoreOne
     */
    public function collection($collection, $createIfNotExist = false)
    {
        $this->collection = $collection;
        if ($createIfNotExist && !$this->isCollection($collection)) {
            $this->createCollection($collection);
        }
        return $this;
    }

    /**
     * Check a collection
     *
     * @param $collection
     *
     * @return bool It returns false if it's not a collection (a valid folder)
     */
    public function isCollection($collection)
    {
        $this->collection = $collection;
        return is_dir($this->getPath());
    }

    /**
     * Creates a collection
     *
     * @param $collection
     *
     * @return bool true if the operation is right, false if it fails.
     */
    public function createCollection($collection)
    {
        $oldCollection = $this->collection;
        $this->collection = $collection;
        $r = @mkdir($this->getPath());
        if($r===false) {
            $this->throwError('error create collection :'.@error_get_last());
        }
        $this->collection = $oldCollection;
        return $r;
    }

    /**
     * It deletes a collection inside a database
     *
     * @param string $collection
     * @param boolean $throwOnError
     * @return void
     */
    public function deleteCollection($collection,$throwOnError=false) {
        $oldCollection = $this->collection;
        $this->collection = $collection;
        $r=rmdir($this->getPath());
        if($r===false && $throwOnError) {
            $this->throwError('error create collection :'.@error_get_last());
        }
        $this->collection = $oldCollection;
    }

    /**
     * It sets if we want to auto serialize the information, and we set how it is serialized
     *      php = it serializes using serialize() function
     *      php_array = it serializes using include()/var_export() function. The result could be cached using OpCache
     *      json_object = it is serialized using json (as object)
     *      json_array = it is serialized using json (as array)
     *      none = it is not serialized. Information must be serialized/de-serialized manually
     *      php_array = it is serialized as a php_array
     *
     * @param bool   $value
     * @param string $strategy =['php','php_array','json_object','json_array','csv','none'][$i]
     */
    public function autoSerialize($value = true, $strategy = 'php')
    {
        $this->autoSerialize = $value;
        if($strategy==='csv') {
            $this->tabular=true;
        }
        $this->serializeStrategy = $strategy;
    }

    /**
     * It sets the style of the csv.
     *
     * @param string $separator
     * @param string $enclosure The enclosure of a string value.
     * @param string $lineEnd
     * @param string $header    If the csv contains or not a header
     * @param string $prefixColumn If the csv or the data does not contains name, then it uses this value to create a
     *                             column name<br>
     *                             <b>Example:</b><br>
     *                             'col': columns 'col0','col1',etc.<br>
     *                             '': columns 0,1
     *
     * @return void
     */
    public function csvStyle($separator = ',', $enclosure = '"', $lineEnd = "\n", $header = true, $prefixColumn = '')
    {
        $this->csvSeparator = $separator;
        $this->csvText = $enclosure;
        $this->csvLineEnd = $lineEnd;
        $this->csvHeader = $header;
        $this->csvPrefixColumn = $prefixColumn;
    }

    /**
     * It sets the regional style
     *
     * @param string $regionalDecimal
     * @param string $regionalDate
     * @param string $regionalDateTime
     * @return void
     */
    public function regionalStyle($regionalDecimal = '.', $regionalDate = 'Y-m-d', $regionalDateTime = 'Y-m-d H:i:s')
    {
        $this->regionDecimal = $regionalDecimal;
        $this->regionDate = $regionalDate;
        $this->regionDateTime = $regionalDateTime;
    }

    /**
     * List all the Ids in a collection (or returns the documents if $returnOnlyIndex is false)
     *
     * @param string $mask see http://php.net/manual/en/function.glob.php
     *
     * @param bool   $returnOnlyIndex
     *                     If false then it returns each document.
     *                     If returns (default) then it return indexes.
     *
     * @return array|false
     */
    public function select($mask = "*", $returnOnlyIndex = true)
    {
        $list = glob($this->database . "/" . $this->collection . "/" . $mask . $this->docExt);
        foreach ($list as $key => $fileId) {
            $list[$key] = basename($fileId, $this->docExt);
        }
        if ($returnOnlyIndex) {
            return $list;
        }

        $listDoc = [];
        foreach ($list as $fileId) {
            $listDoc[] = $this->get($fileId);
        }
        return $listDoc;
    }

    /**
     * Get a document from the datastore<br>
     * <b>Example:</b><br>
     * <pre>
     * $data=$this->get('rows',-1,false); // it returns a value or false
     * $data=$this->get('rows',-1,"not null"); // it returns a value or "not null" if not found
     * </pre>
     *
     * @param string $id      Id of the document.
     * @param int    $tries   number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     * @param mixed  $default Default value (if the value is not found)
     *
     * @return mixed The object if the information was read, otherwise false (or default value).
     */
    public function get($id, $tries = -1, $default = false)
    {
        $file = $this->filename($id);
        $this->currentId = $id;
        if ($this->lock($file, $tries)) {
            if ($this->serializeStrategy === 'php_array') {
                $json = @include $file;
                $this->unlock($file);
            } else {
                $json = @file_get_contents($file);
                $this->unlock($file);
                if (strpos($json, $this->separatorAppend) === false) {
                    if ($this->autoSerialize) {
                        $json = $this->deserialize($json);
                    }
                } else {
                    $arr = explode($this->separatorAppend, $json);
                    if (count($arr) > 0 && $arr[0] === '') {
                        unset($arr[0]);
                    }
                    $json = [];
                    foreach ($arr as $item) {
                        $json[] = $this->deserialize($item);
                    }
                }
            }
            if($json===false) {
                $this->throwError(error_get_last());
            }
            return ($json === false) ? $default : $json;
        }
        return $default;
    }

    private function deserialize($document)
    {
        switch ($this->serializeStrategy) {
            // php_array should be included.
            //case 'php_array':
            //    return self::serialize_php_array($document);
            case 'php':
                return unserialize($document);
            case 'json_object':
                return json_decode($document, false);
            case 'json_array':
                return json_decode($document, true);
            case 'csv':
                return $this->unserializeCSV($document);
            default:
                // also, for none
                return $document;
        }
    }

    /**
     * It gets the timestamp of a document or false in case of error.
     *
     * @param string $id          Id of the document.
     * @param bool   $returnAsAge if true then it returns the age (from the current timestamp)<br>
     *                            if false then it returns the regular timestamp of the time.
     *
     * @return false|int
     */
    public function getTimeStamp($id, $returnAsAge = false)
    {
        $this->currentId = $id;
        $file = $this->filename($id);
        try {
            $rt = filemtime($file);
        } catch (Exception $ex) {
            $rt = false;
        }
        if ($returnAsAge) {

            if ($rt === false) {
                return false;
            }
            return time() - $rt;
        }
        return $rt;
    }

    /**
     * It gets a values from the datastore filtered by a condition<br>
     * <b>Example:</b><br>
     * <pre>
     * $data=$this->getFiltered('rows',-1,false,['type'=>'busy']); // it returns values [0=>...,1=>...]
     * $data=$this->getFiltered('rows',-1,false,['type'=>'busy'],false); // it returns values [2=>...,4=>..]
     * </pre>
     *
     * @param string $id        Id of the document.
     * @param int    $tries     number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     * @param mixed  $default   default value (if the value is not found)
     * @param array  $condition An associative array with the conditions.
     * @param bool   $reindex   If true then the result is reindexed (starting from zero).
     *
     * @return array
     * @noinspection TypeUnsafeComparisonInspection
     */
    public function getFiltered($id, $tries = -1, $default = false, $condition = [], $reindex = true)
    {
        $rows = $this->get($id, $tries, $default);
        $result = [];
        foreach ($rows as $k => $v) {
            $fail = false;
            foreach ($condition as $k2 => $v2) {
                if (is_object($v)) {
                    if (!isset($v->{$k2}) || $v->{$k2} != $v2) {
                        $fail = true;
                        break;
                    }
                } elseif (!isset($v[$k2]) || $v[$k2] != $v2) {
                    $fail = true;
                    break;
                }
            }
            if (!$fail) {
                if ($reindex) {
                    $result[] = $v;
                } else {
                    $result[$k] = $v;
                }
            }
        }
        return $result;

    }

    /**
     * Delete a document.
     *
     * @param string $id    Id of the document
     * @param int    $tries number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool if it's unable to unlock or the document doesn't exist.
     */
    public function delete($id, $tries = -1,$throwOnError=false)
    {
        $file = $this->filename($id);
        if ($this->lock($file, $tries)) {
            $r = @unlink($file);
            $this->unlock($file);
            if($r===false && $throwOnError) {
                $this->throwError(error_get_last());
            }
            return $r;
        }

        return false;
    }

    /**
     * Copy a document. If the destination exists, it's replaced.
     *
     * @param string $idOrigin
     * @param string $idDestination
     * @param int    $tries number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool true if the operation is correct, otherwise it returns false (unable to lock / unable to copy)
     */
    public function copy($idOrigin, $idDestination, $tries = -1)
    {
        $fileOrigin = $this->filename($idOrigin);
        $fileDestination = $this->filename($idDestination);
        if ($this->lock($fileOrigin, $tries)) {
            if ($this->lock($fileDestination, $tries)) {
                $r = @copy($fileOrigin, $fileDestination);
                $this->unlock($fileOrigin);
                $this->unlock($fileDestination);
                if($r===false) {
                    $this->throwError(error_get_last());
                }
                return $r;
            }

            $this->unlock($fileOrigin);
            $this->throwError("Unable to lock file [$idDestination]");
            return false;
        }
        $this->throwError("Unable to lock file [$idOrigin]");
        return false;
    }

    /**
     * Rename a document. If the destination exists, it's not renamed
     *
     * @param string $idOrigin
     * @param string $idDestination
     * @param int    $tries number of tries. The default value is -1 (it uses the default value $defaultNumRetry)
     *
     * @return bool true if the operation is correct, otherwise it returns false
     *              (unable to lock / unable to rename)
     */
    public function rename($idOrigin, $idDestination, $tries = -1)
    {
        $fileOrigin = $this->filename($idOrigin);
        $fileDestination = $this->filename($idDestination);
        if ($this->lock($fileOrigin, $tries)) {
            if ($this->lock($fileDestination, $tries)) {
                $r = @rename($fileOrigin, $fileDestination);
                $this->unlock($fileOrigin);
                $this->unlock($fileDestination);
                if($r===false) {
                    $this->throwError(error_get_last());
                }
                return $r;
            }

            $this->unlock($fileOrigin);
            return false;
        }

        return false;
    }

}

